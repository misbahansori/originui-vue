{
  "$schema": "https://shadcn-vue.com/schema/registry-item.json",
  "name": "useFileUpload",
  "type": "registry:hook",
  "files": [
    {
      "path": "app/composables/useFileUpload.ts",
      "content": "import { ref, watch, type Ref } from \"vue\";\n\nexport type FileMetadata = {\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  id: string;\n};\n\nexport type FileWithPreview = {\n  file: File | FileMetadata;\n  id: string;\n  preview?: string;\n};\n\nexport type FileUploadOptions = {\n  maxFiles?: number;\n  maxSize?: number;\n  accept?: string;\n  multiple?: boolean;\n  initialFiles?: FileMetadata[];\n  onFilesChange?: (files: FileWithPreview[]) => void;\n  onFilesAdded?: (files: FileWithPreview[]) => void;\n};\n\nexport type FileUploadState = {\n  files: FileWithPreview[];\n  isDragging: boolean;\n  errors: string[];\n};\n\nexport type FileUploadActions = {\n  addFiles: (files: FileList | File[]) => void;\n  removeFile: (id: string) => void;\n  clearFiles: () => void;\n  clearErrors: () => void;\n  handleDragEnter: (e: DragEvent) => void;\n  handleDragLeave: (e: DragEvent) => void;\n  handleDragOver: (e: DragEvent) => void;\n  handleDrop: (e: DragEvent) => void;\n  handleFileChange: (e: Event) => void;\n  openFileDialog: () => void;\n  getInputProps: (props?: { disabled?: boolean }) => {\n    type: string;\n    class: string;\n    onChange: (e: Event) => void;\n    accept: string;\n    multiple: boolean;\n    disabled?: boolean;\n    ref: Ref<HTMLInputElement | null>;\n  };\n};\n\nexport const useFileUpload = (options: FileUploadOptions = {}) => {\n  const {\n    maxFiles = Infinity,\n    maxSize = Infinity,\n    accept = \"*\",\n    multiple = false,\n    initialFiles = [],\n    onFilesChange,\n    onFilesAdded,\n  } = options;\n\n  const files = ref<FileWithPreview[]>(\n    initialFiles.map((file) => ({\n      file,\n      id: file.id,\n      preview: file.url,\n    })),\n  );\n  const isDragging = ref(false);\n  const errors = ref<string[]>([]);\n\n  const inputRef = ref<HTMLInputElement | null>(null);\n\n  const validateFile = (file: File | FileMetadata): string | null => {\n    if (file instanceof File) {\n      if (file.size > maxSize) {\n        return `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n      }\n    } else {\n      if (file.size > maxSize) {\n        return `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n      }\n    }\n\n    if (accept !== \"*\") {\n      const acceptedTypes = accept.split(\",\").map((type) => type.trim());\n      const fileType = file instanceof File ? file.type || \"\" : file.type;\n      const fileExtension = `.${file instanceof File ? file.name.split(\".\").pop() : file.name.split(\".\").pop()}`;\n\n      const isAccepted = acceptedTypes.some((type) => {\n        if (type.startsWith(\".\")) {\n          return fileExtension.toLowerCase() === type.toLowerCase();\n        }\n        if (type.endsWith(\"/*\")) {\n          const baseType = type.split(\"/\")[0];\n          return fileType.startsWith(`${baseType}/`);\n        }\n        return fileType === type;\n      });\n\n      if (!isAccepted) {\n        return `File \"${file instanceof File ? file.name : file.name}\" is not an accepted file type.`;\n      }\n    }\n\n    return null;\n  };\n\n  const createPreview = (file: File | FileMetadata): string | undefined => {\n    if (file instanceof File) {\n      return URL.createObjectURL(file);\n    }\n    return file.url;\n  };\n\n  const generateUniqueId = (file: File | FileMetadata): string => {\n    if (file instanceof File) {\n      return `${file.name}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n    }\n    return file.id;\n  };\n\n  const clearFiles = () => {\n    // Clean up object URLs\n    files.value.forEach((file) => {\n      if (\n        file.preview &&\n        file.file instanceof File &&\n        file.file.type.startsWith(\"image/\")\n      ) {\n        URL.revokeObjectURL(file.preview);\n      }\n    });\n\n    if (inputRef.value) {\n      inputRef.value.value = \"\";\n    }\n\n    files.value = [];\n    errors.value = [];\n    onFilesChange?.(files.value);\n  };\n\n  const addFiles = (newFiles: FileList | File[]) => {\n    if (!newFiles || newFiles.length === 0) return;\n\n    const newFilesArray = Array.from(newFiles);\n    const newErrors: string[] = [];\n\n    // Clear existing errors when new files are uploaded\n    errors.value = [];\n\n    // In single file mode, clear existing files first\n    if (!multiple) {\n      clearFiles();\n    }\n\n    // Check if adding these files would exceed maxFiles (only in multiple mode)\n    if (\n      multiple &&\n      maxFiles !== Infinity &&\n      files.value.length + newFilesArray.length > maxFiles\n    ) {\n      newErrors.push(`You can only upload a maximum of ${maxFiles} files.`);\n      errors.value = newErrors;\n      return;\n    }\n\n    const validFiles: FileWithPreview[] = [];\n\n    newFilesArray.forEach((file) => {\n      // Check for duplicates\n      const isDuplicate = files.value.some(\n        (existingFile) =>\n          existingFile.file.name === file.name &&\n          existingFile.file.size === file.size,\n      );\n\n      // Skip duplicate files silently\n      if (isDuplicate) {\n        return;\n      }\n\n      // Check file size\n      if (file.size > maxSize) {\n        newErrors.push(\n          multiple\n            ? `Some files exceed the maximum size of ${formatBytes(maxSize)}.`\n            : `File exceeds the maximum size of ${formatBytes(maxSize)}.`,\n        );\n        return;\n      }\n\n      const error = validateFile(file);\n      if (error) {\n        newErrors.push(error);\n      } else {\n        validFiles.push({\n          file,\n          id: generateUniqueId(file),\n          preview: createPreview(file),\n        });\n      }\n    });\n\n    // Only update state if we have valid files to add\n    if (validFiles.length > 0) {\n      files.value = !multiple ? validFiles : [...files.value, ...validFiles];\n      errors.value = newErrors;\n      onFilesChange?.(files.value);\n      onFilesAdded?.(validFiles);\n    } else if (newErrors.length > 0) {\n      errors.value = newErrors;\n    }\n\n    // Reset input value after handling files\n    if (inputRef.value) {\n      inputRef.value.value = \"\";\n    }\n  };\n\n  const removeFile = (id: string | undefined) => {\n    if (!id) return;\n\n    const fileToRemove = files.value.find((file) => file.id === id);\n    if (\n      fileToRemove &&\n      fileToRemove.preview &&\n      fileToRemove.file instanceof File &&\n      fileToRemove.file.type.startsWith(\"image/\")\n    ) {\n      URL.revokeObjectURL(fileToRemove.preview);\n    }\n\n    files.value = files.value.filter((file) => file.id !== id);\n    errors.value = [];\n    onFilesChange?.(files.value);\n  };\n\n  const clearErrors = () => {\n    errors.value = [];\n  };\n\n  const handleDragEnter = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    isDragging.value = true;\n  };\n\n  const handleDragLeave = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (\n      e.currentTarget &&\n      e.relatedTarget &&\n      (e.currentTarget as HTMLElement).contains(e.relatedTarget as Node)\n    ) {\n      return;\n    }\n\n    isDragging.value = false;\n  };\n\n  const handleDragOver = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  const handleDrop = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    isDragging.value = false;\n\n    // Don't process files if the input is disabled\n    if (inputRef.value?.disabled) {\n      return;\n    }\n\n    if (e.dataTransfer?.files && e.dataTransfer.files.length > 0) {\n      // In single file mode, only use the first file\n      if (!multiple) {\n        const file = e.dataTransfer.files[0];\n        if (file) {\n          addFiles([file]);\n        }\n      } else {\n        addFiles(e.dataTransfer.files);\n      }\n    }\n  };\n\n  const handleFileChange = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    if (target.files && target.files.length > 0) {\n      addFiles(target.files);\n    }\n  };\n\n  const openFileDialog = () => {\n    if (inputRef.value) {\n      inputRef.value.click();\n    }\n  };\n\n  const getInputProps = (props: { disabled?: boolean } = {}) => {\n    return {\n      type: \"file\",\n      class: \"sr-only\",\n      onChange: handleFileChange,\n      accept,\n      multiple,\n      disabled: props.disabled,\n      ref: inputRef,\n    };\n  };\n\n  // Watch for changes in files and call onFilesChange if provided\n  watch(\n    files,\n    (newFiles) => {\n      onFilesChange?.(newFiles);\n    },\n    { deep: true },\n  );\n\n  return {\n    files,\n    isDragging,\n    errors,\n    addFiles,\n    removeFile,\n    clearFiles,\n    clearErrors,\n    handleDragEnter,\n    handleDragLeave,\n    handleDragOver,\n    handleDrop,\n    handleFileChange,\n    openFileDialog,\n    getInputProps,\n    onFilesAdded,\n  };\n};\n\nexport const formatBytes = (bytes: number, decimals = 2): string => {\n  if (bytes === 0) return \"0 Bytes\";\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return (\n    Number.parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + (sizes[i] || \"\")\n  );\n};\n",
      "type": "registry:hook"
    }
  ],
  "dependencies": [],
  "registryDependencies": []
}