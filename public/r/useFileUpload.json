{
  "$schema": "https://shadcn-vue.com/schema/registry-item.json",
  "name": "useFileUpload",
  "type": "registry:hook",
  "files": [
    {
      "path": "app/composables/useFileUpload.ts",
      "content": "import { ref, watch, shallowRef, computed, type Ref } from \"vue\";\n\nexport type FileMetadata = {\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  id: string;\n};\n\nexport type FileWithPreview = {\n  file: File | FileMetadata;\n  id: string;\n  preview?: string;\n};\n\nexport type FileUploadOptions = {\n  maxFiles?: number;\n  maxSize?: number;\n  accept?: string;\n  multiple?: boolean;\n  initialFiles?: FileMetadata[];\n  onFilesChange?: (files: FileWithPreview[]) => void;\n  onFilesAdded?: (files: FileWithPreview[]) => void;\n};\n\nexport const useFileUpload = (options: FileUploadOptions = {}) => {\n  const {\n    maxFiles = Infinity,\n    maxSize = Infinity,\n    accept = \"*\",\n    multiple = false,\n    initialFiles = [],\n    onFilesChange,\n    onFilesAdded,\n  } = options;\n\n  const files = ref<FileWithPreview[]>(\n    initialFiles.map((file) => ({\n      file,\n      id: file.id,\n      preview: file.url,\n    })),\n  );\n\n  const errors = ref<string[]>([]);\n\n  const ariaLabel = computed(() => {\n    if (files.value.length > 0) {\n      return multiple ? \"Change files\" : \"Change file\";\n    }\n    return multiple ? \"Upload files\" : \"Upload file\";\n  });\n\n  const inputRef = shallowRef<HTMLInputElement | null>(null);\n  const dropzoneRef = shallowRef<HTMLElement | null>(null);\n\n  watch(inputRef, (newInput) => {\n    if (!newInput) return;\n    configureInput();\n  });\n\n  const configureInput = () => {\n    if (!inputRef.value) return;\n    inputRef.value.type = \"file\";\n    inputRef.value.className = \"sr-only\";\n    inputRef.value.accept = accept;\n    inputRef.value.multiple = multiple;\n    inputRef.value.addEventListener(\"change\", handleFileChange);\n  };\n\n  watch(dropzoneRef, (newDropzone) => {\n    if (!newDropzone) return;\n    configureDropzone();\n  });\n\n  const configureDropzone = () => {\n    if (!dropzoneRef.value) return;\n    dropzoneRef.value.addEventListener(\"dragenter\", handleDragEnter);\n    dropzoneRef.value.addEventListener(\"dragleave\", handleDragLeave);\n    dropzoneRef.value.addEventListener(\"dragover\", handleDragOver);\n    dropzoneRef.value.addEventListener(\"drop\", handleDrop);\n\n    dropzoneRef.value.setAttribute(\"aria-label\", ariaLabel.value);\n  };\n\n  watch(ariaLabel, (newValue) => {\n    if (!dropzoneRef.value) return;\n    dropzoneRef.value.setAttribute(\"aria-label\", newValue);\n  });\n\n  const validateFile = (file: File | FileMetadata): string | null => {\n    if (file instanceof File) {\n      if (file.size > maxSize) {\n        return `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n      }\n    } else {\n      if (file.size > maxSize) {\n        return `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n      }\n    }\n\n    if (accept !== \"*\") {\n      const acceptedTypes = accept.split(\",\").map((type) => type.trim());\n      const fileType = file instanceof File ? file.type || \"\" : file.type;\n      const fileExtension = `.${file instanceof File ? file.name.split(\".\").pop() : file.name.split(\".\").pop()}`;\n\n      const isAccepted = acceptedTypes.some((type) => {\n        if (type.startsWith(\".\")) {\n          return fileExtension.toLowerCase() === type.toLowerCase();\n        }\n        if (type.endsWith(\"/*\")) {\n          const baseType = type.split(\"/\")[0];\n          return fileType.startsWith(`${baseType}/`);\n        }\n        return fileType === type;\n      });\n\n      if (!isAccepted) {\n        return `File \"${file instanceof File ? file.name : file.name}\" is not an accepted file type.`;\n      }\n    }\n\n    return null;\n  };\n\n  const createPreview = (file: File | FileMetadata): string | undefined => {\n    if (file instanceof File) {\n      return URL.createObjectURL(file);\n    }\n    return file.url;\n  };\n\n  const generateUniqueId = (file: File | FileMetadata): string => {\n    if (file instanceof File) {\n      return `${file.name}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n    }\n    return file.id;\n  };\n\n  const clearFiles = () => {\n    files.value.forEach((file) => {\n      if (\n        file.preview &&\n        file.file instanceof File &&\n        file.file.type.startsWith(\"image/\")\n      ) {\n        URL.revokeObjectURL(file.preview);\n      }\n    });\n\n    if (inputRef.value) {\n      inputRef.value.value = \"\";\n    }\n\n    files.value = [];\n    errors.value = [];\n    onFilesChange?.(files.value);\n  };\n\n  const addFiles = (newFiles: FileList | File[]) => {\n    if (!newFiles || newFiles.length === 0) return;\n\n    const newFilesArray = Array.from(newFiles);\n    const newErrors: string[] = [];\n\n    errors.value = [];\n\n    if (!multiple) {\n      clearFiles();\n    }\n\n    if (\n      multiple &&\n      maxFiles !== Infinity &&\n      files.value.length + newFilesArray.length > maxFiles\n    ) {\n      newErrors.push(`You can only upload a maximum of ${maxFiles} files.`);\n      errors.value = newErrors;\n      return;\n    }\n\n    const validFiles: FileWithPreview[] = [];\n\n    newFilesArray.forEach((file) => {\n      const isDuplicate = files.value.some(\n        (existingFile) =>\n          existingFile.file.name === file.name &&\n          existingFile.file.size === file.size,\n      );\n\n      if (isDuplicate) {\n        return;\n      }\n\n      if (file.size > maxSize) {\n        newErrors.push(\n          multiple\n            ? `Some files exceed the maximum size of ${formatBytes(maxSize)}.`\n            : `File exceeds the maximum size of ${formatBytes(maxSize)}.`,\n        );\n        return;\n      }\n\n      const error = validateFile(file);\n      if (error) {\n        newErrors.push(error);\n      } else {\n        validFiles.push({\n          file,\n          id: generateUniqueId(file),\n          preview: createPreview(file),\n        });\n      }\n    });\n\n    if (validFiles.length > 0) {\n      files.value = !multiple ? validFiles : [...files.value, ...validFiles];\n      errors.value = newErrors;\n      onFilesChange?.(files.value);\n      onFilesAdded?.(validFiles);\n    } else if (newErrors.length > 0) {\n      errors.value = newErrors;\n    }\n\n    if (inputRef.value) {\n      inputRef.value.value = \"\";\n    }\n  };\n\n  const removeFile = (id: string | undefined) => {\n    if (!id) return;\n\n    const fileToRemove = files.value.find((file) => file.id === id);\n    if (\n      fileToRemove &&\n      fileToRemove.preview &&\n      fileToRemove.file instanceof File &&\n      fileToRemove.file.type.startsWith(\"image/\")\n    ) {\n      URL.revokeObjectURL(fileToRemove.preview);\n    }\n\n    files.value = files.value.filter((file) => file.id !== id);\n    errors.value = [];\n    onFilesChange?.(files.value);\n  };\n\n  const clearErrors = () => {\n    errors.value = [];\n  };\n\n  const handleDragEnter = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (dropzoneRef.value) {\n      dropzoneRef.value.setAttribute(\"data-dragging\", \"true\");\n    }\n  };\n\n  const handleDragLeave = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (\n      e.currentTarget &&\n      e.relatedTarget &&\n      (e.currentTarget as HTMLElement).contains(e.relatedTarget as Node)\n    ) {\n      return;\n    }\n\n    if (dropzoneRef.value) {\n      dropzoneRef.value.removeAttribute(\"data-dragging\");\n    }\n  };\n\n  const handleDragOver = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  const handleDrop = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (dropzoneRef.value) {\n      dropzoneRef.value.removeAttribute(\"data-dragging\");\n    }\n\n    if (inputRef.value?.disabled) {\n      return;\n    }\n\n    if (e.dataTransfer?.files && e.dataTransfer.files.length > 0) {\n      if (!multiple) {\n        const file = e.dataTransfer.files[0];\n        if (file) {\n          addFiles([file]);\n        }\n      } else {\n        addFiles(e.dataTransfer.files);\n      }\n    }\n  };\n\n  const handleFileChange = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    if (target.files && target.files.length > 0) {\n      addFiles(target.files);\n    }\n  };\n\n  const openFileDialog = () => {\n    if (inputRef.value) {\n      inputRef.value.click();\n    }\n  };\n\n  watch(\n    files,\n    (newFiles) => {\n      onFilesChange?.(newFiles);\n    },\n    { deep: true },\n  );\n\n  return {\n    files,\n    errors,\n    addFiles,\n    removeFile,\n    clearFiles,\n    clearErrors,\n    handleFileChange,\n    openFileDialog,\n    onFilesAdded,\n    inputRef,\n    dropzoneRef,\n  };\n};\n\nexport const formatBytes = (bytes: number, decimals = 2): string => {\n  if (bytes === 0) return \"0 Bytes\";\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return (\n    Number.parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + (sizes[i] || \"\")\n  );\n};\n",
      "type": "registry:hook"
    }
  ],
  "dependencies": [],
  "registryDependencies": []
}